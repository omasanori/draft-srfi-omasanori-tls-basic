= SRFI nnn: Basic TLS connections
Masanori Ogino
:toc: macro

[discrete]
== Status

Early Draft

toc::[]

[abstract]
== Abstract

This SRFI specifies a set of interfaces to establish secure connections to
and communicate with peers using the Transport Layer Security (TLS) protocol.
It focuses on simplicity over flexibility and is intended to cover typical use
cases.

== Issues

* Complete the specification
* Check the portability of `tls-add-keypair`
* Revisit private key problems (buffered I/O, password, wipe data after use)

== Rationale

As described in RFC 7258, large-scale surveillance is recognized as a privacy
threat nowadays, and the design of internet protocols has been shifting toward
encrypted-by-default, using TLS or similar protocols. Thus, a portable API for
TLS benefits programmers in writing networking code.

Historically, TLS libraries have provided many functions. However, it leads to
bloat and misconfiguration and, ultimately, vulnerabilities. An API for secure
communications should not require programmers a lot of work to achieve secure
communications. This SRFI is significantly influenced by libtls, a TLS library
developed by the OpenBSD community "`as a response to the unnecessary
challenges other APIs present in order to use them safely.`" Furthermore, this
SRFI reduces the number of interfaces to provide essential functionalities
while supporting various implementations. The interfaces, however, provide room
for extensions by future SRFIs and implementations.

This SRFI requires a port I/O API. It optinally depends on a socket API that
may conform to SRFI 106. It defines feature identifiers (see SRFI 0) and
version flags (see SRFI 176).

=== Omitted features and interfaces

This SRFI omits file- and path-based interfaces to support implementations for
embedded systems. It omits the ability to specify detailed parameters as it can
be easily misused. It omits inspection of established connections for
simplicity. It omits Application-Layer Protocol Negotiation (ALPN) and Online
Certificate Status Protocol (OCSP) supports since they depend on inspection of
established connections. SRFI <tls-advanced> addresses them.

It omits configuration for insecure connections, like enabling obsolete
protocol versions and weak cipher suites or disabling certificate validations.
While we know some use cases, we drop these functionalities from the interfaces
for simplicity. SRFI <tls-insecure> addresses this.

=== Survey of prior art

== Specification

The words and phrases "`an error is signaled`",
"`an error that satisfies _predicate_ is signaled`", "`an error`",
"`may report a violation of an implementation restriction`", "`unspecified`",
"`must`", "`must not`", "`shall`", "`shall not`", "`should`", "`should not`",
"`may`", "`required`", "`recommended`", and "`optional`" in this specification
are to be interpreted as described in R7RS, section 1.3.2.

An implementation must provide configuration, context, and client or server
interfaces specified below. An implementation may provide both the server and
client interfaces.

=== Feature identifiers and version flags

An implementation may provide any or all of the feature identifiers and version
flags.

==== Feature identifier: `tls-client`

Client interfaces are provided.

==== Feature identifier: `tls-server`

Server interfaces are provided.

==== Feature identifier: `tls-socket`

`tls-connect-socket`, `tls-accept-socket`, or both of them are provided.

==== Version flag: `tls.name string`

The name of underlying TLS implementation to implement interfaces defined by
this specification.

==== Version flag: `tls.version string`

The version of underlying TLS implementation to implement interfaces defined by
this specification.

=== Configuration interfaces

==== Procedure: `tls-configuration? _object -> boolean_`

==== Procedure: `tls-configuration _-> conf_`

==== Procedure: `tls-set-protocols _conf protocol -> unspecified_`

==== Procedure: `tls-set-ciphers _conf cipher -> unspecified_`

==== Procedure: `tls-set-ca _conf port -> unspecified_`

==== Procedure: `tls-set-cert _conf port -> unspecified_`

==== Procedure: `tls-set-crl _conf port -> unspecified_`

==== Procedure: `tls-set-key _conf port -> unspecified_`

==== Procedure: `tls-set-keypair _conf cert-port key-port -> unspecified_`

==== Procedure: `tls-add-keypair _conf cert-port key-port -> unspecified_`

==== Procedure: `tls-clear-keys _conf -> unspecified_`

==== Procedure: `tls-set-verify-depth _conf depth -> unspecified_`

=== Context interfaces

==== Procedure: `tls-context? _object -> boolean_`

==== Procedure: `tls-handshake _context -> unspecified_`

==== Procedure: `tls-input-port _context -> port_`

==== Procedure: `tls-output-port _context -> port_`

==== Procedure: `tls-close _context -> unspecified_`

==== Procedure: `tls-reset _context -> unspecified_`

=== Client interfaces

==== Procedure: `tls-client _conf -> context_`

==== Procedure: `tls-connect _context host service -> unspecified_`

==== Procedure: `tls-connect-servername _context host service servername -> unspecified_`

==== Procedure: `tls-connect-socket _context socket servername -> unspecified_`

=== Server interfaces

==== Procedure: `tls-verify-client _conf -> unspecified_`

==== Procedure: `tls-verify-client-optional _conf -> unspecified_`

==== Procedure: `tls-server _conf -> context_`

==== Procedure: `tls-accept _context service -> context_`

==== Procedure: `tls-accept-socket _context socket -> context_`

== Examples

== Implementation

??? explanation of how it meets the sample implementation requirement (see
process), and the code, if possible, or a link to it.

At least, this SRFI should be able to implement with the following libraries:

* GnuTLS: widely used, used by Guile
* Mbed TLS: designed for embedded systems, used by Gauche
* OpenSSL: widely used, used by Chibi and Chicken
* A TLS implementation on Java VM (`javax.net.ssl` or Bouncy Castle?)
* A TLS implementation on .NET (`System.Net.Security` or Bouncy Castle?)

Additionally, the following libraries may be taken into account:

* Amazon s2n-tls
* Apple Secure Transport
* axTLS (no commit to the repository since 2019, safe to drop?)
* BearSSL
* Microsoft Secure Channel
* miTLS by Project Everest
* Mozilla Network Security Services
* wolfSSL

== Acknowledgements

??? Give credits where credits is due.

== References

=== IETF RFCs

* Rescorla, E., "`The Transport Layer Security (TLS) Protocol Version 1.3`", RFC 8446, August 2018.
* Farrell, S. and Tschofenig, H., "`Pervasive Monitoring Is an Attack`", BCP 188, RFC 7258, May 2014.
* Sheffer, Y., Holz, R., and Saint-Andre, P., "`Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)`", BCP 195, RFC 7525, May 2015. 
* Moriarty, K. and Farrell, S., "`Deprecating TLS 1.0 and TLS 1.1`", BCP 195, RFC 8996, March 2021.

=== Manuals

* Sing, J., et al., "`tls_init, tls_config_new, tls_config_free, tls_config_error â€” initialize TLS client and server API`", tls_init(3), OpenBSD manual pages, July 2018.
* Vehent, J., et al., "`Server Side TLS`", Mozilla Wiki, April 2022. Available at https://wiki.mozilla.org/Security/Server_Side_TLS.

== Copyright

Copyright &copy; 2022 Masanori Ogino

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
